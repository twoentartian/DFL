#pragma once

#include <network.hpp>
#include <mutex>
#include <glog/logging.h>

#include <boost_serialization_wrapper.hpp>

#include "transaction.hpp"
#include "global_types.hpp"
#include "global_var.hpp"
#include "command_allocation.hpp"
#include "std_output.hpp"
#include "block.hpp"
#include "transaction_storage_for_block.hpp"

class transaction_tran_rece
{
public:
	using receive_transaction_callback = std::function<void(const transaction& /*trans*/)>;
	using receive_block_callback = std::function<void(const block& /*block*/)>;
	using receive_block_confirmation_callback = std::function<void(const block_confirmation& /*confirmation*/)>;
	
	////we need the transaction_storage_for_block to verify/generate block confirmation
	transaction_tran_rece(std::shared_ptr<transaction_storage_for_block> main_transaction_storage_for_block)
	{
		_main_transaction_storage_for_block = main_transaction_storage_for_block;
	}

	void start_listen(uint16_t listen_port)
	{
		using namespace network;
		_p2p.start_service(listen_port);
		_p2p.set_receive_callback([this](header::COMMAND_TYPE command, const char *data, int length) -> std::tuple<header::COMMAND_TYPE, std::string> {
			if (command == command::transaction)
			{
				//this is a transaction
				std::stringstream ss;
				ss << std::string(data, length);
				transaction trans;
				try
				{
					trans = deserialize_wrap<boost::archive::binary_iarchive, transaction>(ss);
				}
				catch (...)
				{
					LOG(WARNING) << "cannot parse packet data";
					return {command::acknowledge_but_not_accepted, "cannot parse packet data"};
				}
				std::thread temp_thread([this, trans](){
					for (auto&& cb : _receive_transaction_callbacks)
					{
						cb(trans);
					}
				});
				temp_thread.detach();
				
				return {command::acknowledge, ""};
			}
			else if(command == command::block)
			{
				//this is a block
				std::stringstream ss;
				ss << std::string(data, length);
				block blk;
				try
				{
					blk = deserialize_wrap<boost::archive::binary_iarchive, block>(ss);
				}
				catch (...)
				{
					LOG(WARNING) << "cannot parse packet data";
					return {command::acknowledge_but_not_accepted, "cannot parse packet data"};
				}
				
				//find the verified transaction
				std::vector<block_confirmation> confirmations;
				for (auto& [single_transaction_hash, single_transaction]: blk.content.transaction_container)
				{
					if (single_transaction_hash != single_transaction.hash_sha256)
					{
						LOG(WARNING) << "receive a bad block: " << blk.block_content_hash << " from " << blk.content.creator.node_address << ", bad transaction hash";
						return {command::acknowledge_but_not_accepted, "bad block"};
					}
					
					for (auto& [receipt_hash, receipt]: single_transaction.receipts)
					{
						if (receipt_hash != receipt.hash_sha256)
						{
							LOG(WARNING) << "receive a bad block: " << blk.block_content_hash << " from " << blk.content.creator.node_address << ", bad receipt hash";
							return {command::acknowledge_but_not_accepted, "bad block"};
						}
						if (receipt.content.creator.node_address == global_var::address.getTextStr_lowercase())
						{
							//find a receipt generated by me
							if (_main_transaction_storage_for_block->check_verified_transaction(single_transaction) == transaction_storage_for_block::check_receipt_return::pass)
							{
								//generate confirmation
								block_confirmation single_confirmation;
								single_confirmation.creator.node_address = global_var::address.getTextStr_lowercase();
								single_confirmation.creator.node_pubkey = global_var::public_key.getTextStr_lowercase();
								single_confirmation.block_hash = blk.block_content_hash;
								single_confirmation.transaction_hash = single_transaction_hash;
								single_confirmation.receipt_hash = receipt_hash;
								
								auto hash_hex = crypto::sha256_digest(single_confirmation);
								single_confirmation.final_hash = hash_hex.getTextStr_lowercase();
								auto signature = crypto::ecdsa_openssl::sign(hash_hex, global_var::private_key);
								single_confirmation.signature = signature.getTextStr_lowercase();
								
								confirmations.push_back(single_confirmation);
							}
							else
							{
								//do nothing, because the verified transaction is not found in the database
								//TODO: record this abnormal behaviour in log?
							}
						}
					}
				}
				
				//callbacks
				std::thread temp_thread([this, blk](){
					for (auto&& cb : _receive_block_callbacks)
					{
						cb(blk);
					}
				});
				temp_thread.detach();
				
				if (confirmations.empty())
				{
					return {command::acknowledge, ""};
				}
				else
				{
					std::string confirmation_data = serialize_wrap<boost::archive::binary_oarchive>(confirmations).str();
					return {command::block_confirmation, confirmation_data};
				}
			}
			else
			{
				LOG(WARNING) << "[p2p] unknown command";
				return {command::unknown, ""};
			}
			
		});
	}
	
	void broadcast_transaction(const transaction& trans)
	{
		const std::string& trans_hash = trans.hash_sha256;
		
		std::string trans_binary_str = serialize_wrap<boost::archive::binary_oarchive>(trans).str();
		std::vector<peer_enpoint> peers_copy;
		{
			std::lock_guard guard(_peers_lock);
			peers_copy = _peers;
		}
		
		for (auto&& peer: peers_copy)
		{
			using namespace network;
			_p2p.send(peer.address, peer.port, i_p2p_node_with_header::ipv4, command::transaction, trans_binary_str.data(), trans_binary_str.length(), [trans_hash, peer](i_p2p_node_with_header::send_packet_status status, header::COMMAND_TYPE received_command, const char* data, int length){
				std::stringstream ss;
				ss << "[transaction trans] send transaction with hash " << trans_hash << " to " << peer.to_string() << ", send status: " << i_p2p_node_with_header::send_packet_status_message[status];
				auto ss_str = ss.str();
				LOG(INFO) << ss_str;
				std_cout::println(ss_str);
			});
		}
	}
	
	std::vector<block_confirmation> broadcast_block_and_receive_confirmation(const block& blk)
	{
		std::vector<block_confirmation> output_confirmations;
		
		std::string block_binary_str = serialize_wrap<boost::archive::binary_oarchive>(blk).str();
		std::vector<peer_enpoint> peers_copy;
		{
			std::lock_guard guard(_peers_lock);
			peers_copy = _peers;
		}
		
		for (auto&& peer: peers_copy)
		{
			using namespace network;
			_p2p.send(peer.address, peer.port, i_p2p_node_with_header::ipv4, command::block, block_binary_str.data(), block_binary_str.length(), [&peer, &blk, &output_confirmations](i_p2p_node_with_header::send_packet_status status, header::COMMAND_TYPE command_received, const char* data, int length){
				std::string received_data(data, length);
				if (command_received == command::acknowledge)
				{
					std::stringstream ss;
					ss << "[transaction trans] send block " << blk.block_content_hash << " to " << peer.to_string();
					auto ss_str = ss.str();
					LOG(INFO) << ss_str;
					std_cout::println(ss_str);
					//no confirmation provide, do nothing
				}
				else if (command_received == command::block_confirmation)
				{
					//TODO:check confirmation
					std::vector<block_confirmation> confirmations = deserialize_wrap<boost::archive::binary_iarchive, std::vector<block_confirmation>>(received_data);
					for (auto& confirmation: confirmations)
					{
						output_confirmations.push_back(confirmation);
					}
					
					std::stringstream ss;
					ss << "[transaction trans] send block " << blk.block_content_hash << " to " << peer.to_string() << " and receive " << confirmations.size() << " block confirmation";
					auto ss_str = ss.str();
					LOG(INFO) << ss_str;
					std_cout::println(ss_str);
				}
			});
		}
		
		return output_confirmations;
	}
	
	void set_receive_transaction_callback(receive_transaction_callback callback)
	{
		_receive_transaction_callbacks.push_back(callback);
	}
	
	void set_receive_block_callback(receive_block_callback callback)
	{
		_receive_block_callbacks.push_back(callback);
	}
	
	void set_receive_block_confirmation_callback(receive_block_confirmation_callback callback)
	{
		_receive_block_confirmation_callbacks.push_back(callback);
	}

	void add_peer(const std::string& address, uint16_t port)
	{
		peer_enpoint temp(address, port);
		{
			std::lock_guard guard(_peers_lock);
			_peers.push_back(temp);
		}
	}
	
private:
	std::vector<receive_transaction_callback> _receive_transaction_callbacks;
	std::vector<receive_block_callback> _receive_block_callbacks;
	std::vector<receive_block_confirmation_callback> _receive_block_confirmation_callbacks;
	network::p2p_with_header _p2p;
	std::vector<peer_enpoint> _peers;
	std::mutex _peers_lock;
	std::shared_ptr<transaction_storage_for_block> _main_transaction_storage_for_block;
};
